From 29eee798dec5614ae6de137feb5ab1bac9ba1712 Mon Sep 17 00:00:00 2001
From: freedomcondor <zhuweixu_harry@126.com>
Date: Wed, 21 Feb 2018 12:51:35 +0100
Subject: [PATCH] vcnl

---
 drivers/iio/light/vcnl4000.c | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/drivers/iio/light/vcnl4000.c b/drivers/iio/light/vcnl4000.c
index 360b6e9..eba0316 100644
--- a/drivers/iio/light/vcnl4000.c
+++ b/drivers/iio/light/vcnl4000.c
@@ -53,10 +53,20 @@ struct vcnl4000_data {
 
 static const struct i2c_device_id vcnl4000_id[] = {
 	{ "vcnl4000", 0 },
+	{ "vcnl4010", 0 },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, vcnl4000_id);
 
+/*  add of_table by Harry ZHU */
+static const struct of_device_id of_vcnl4000_ids[] = {
+	{ .compatible = "vishay,vcnl4000" },
+	{ .compatible = "vishay,vcnl4010" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, of_vcnl4000_ids);
+/*  end of add of_table by Harry ZHU */
+
 static int vcnl4000_measure(struct vcnl4000_data *data, u8 req_mask,
 				u8 rdy_mask, u8 data_reg, int *val)
 {
@@ -165,23 +175,43 @@ static int vcnl4000_probe(struct i2c_client *client,
 	struct iio_dev *indio_dev;
 	int ret, prod_id;
 
+	/*  add check mark by Harry ZHU */
+	dev_dbg(&client->dev, "probe start\n");
+	dev_err(&client->dev, "probe start\n");
+
 	indio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
 	if (!indio_dev)
 		return -ENOMEM;
 
+	/*  add check mark by Harry ZHU */
+	dev_dbg(&client->dev, "after device alloc\n");
+	dev_err(&client->dev, "after device alloc\n");
+
 	data = iio_priv(indio_dev);
 	i2c_set_clientdata(client, indio_dev);
 	data->client = client;
 	mutex_init(&data->lock);
 
+	/*  add check mark by Harry ZHU */
+	dev_dbg(&client->dev, "after data\n");
+	dev_err(&client->dev, "after data\n");
+
 	ret = i2c_smbus_read_byte_data(data->client, VCNL4000_PROD_REV);
 	if (ret < 0)
 		return ret;
 
+	/*  add check mark by Harry ZHU */
+	dev_dbg(&client->dev, "after read data\n");
+	dev_err(&client->dev, "after read data\n");
+
 	prod_id = ret >> 4;
 	if (prod_id != VCNL4010_ID && prod_id != VCNL4000_ID)
 		return -ENODEV;
 
+	/*  add check mark by Harry ZHU */
+	dev_dbg(&client->dev, "after check probe id\n");
+	dev_err(&client->dev, "after check probe id\n");
+
 	dev_dbg(&client->dev, "%s Ambient light/proximity sensor, Rev: %02x\n",
 		(prod_id == VCNL4010_ID) ? "VCNL4010/4020" : "VCNL4000",
 		ret & 0xf);
@@ -193,12 +223,17 @@ static int vcnl4000_probe(struct i2c_client *client,
 	indio_dev->name = VCNL4000_DRV_NAME;
 	indio_dev->modes = INDIO_DIRECT_MODE;
 
+	/*  add check mark by Harry ZHU */
+	dev_dbg(&client->dev, "before last return\n");
+	dev_err(&client->dev, "before last return\n");
+
 	return devm_iio_device_register(&client->dev, indio_dev);
 }
 
 static struct i2c_driver vcnl4000_driver = {
 	.driver = {
 		.name   = VCNL4000_DRV_NAME,
+		.of_match_table = of_match_ptr(of_vcnl4000_ids),
 	},
 	.probe  = vcnl4000_probe,
 	.id_table = vcnl4000_id,
-- 
2.7.4

